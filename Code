#include <msp430.h>

int security = 291;
int byte = 0;
int first_byte = 0;
int second_byte = 0;
int third_byte = 0;
int fourth_byte = 0;
int fifth_byte = 0;
int admin_byte = 204;
int encrypted1 = 0;
int encrypted2 = 0;
int encrypted3 = 0;


void UART_init()
{
    P4SEL |= BIT4+BIT5;                       // P4.4,5 = USCI_A1 TXD/RXD
    UCA1CTL1 |= UCSWRST;                      // **Put state machine in reset**
    UCA1CTL1 |= UCSSEL_2;                     // USCI clock source select, SMCLK
    UCA1BR0 = 104;                            // Low byte of baud-rate generator, prescalar setting for 9600 baud rate
    UCA1BR1 = 0;                              // High byte of baud-rate generator
    UCA1CTL1 &= ~UCSWRST;                     // **Initialize USCI state machine**
    UCA1IE |= UCRXIE;                         // Enable USCI_A1 RX interrupt
}

void TimerA_init()
{
    TA2CTL = TASSEL_2 + MC_1 + TACLR; // SMCLK, up-down mode, clear
    TA2CCR0 = 20000; // PWM Period
    TA2CCR2 = 2500;
    TA2CCTL2 = OUTMOD_7; // CCR1 toggle/set
}

void security_algorithm()
{
    encrypted1 = first_byte + third_byte;
    encrypted2 = second_byte + fourth_byte;
    encrypted3 = (5 * encrypted1) - (4 * encrypted2);
}

int main(void)
{
    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
    UART_init();
    TimerA_init();
    P2DIR |= BIT5; //P2.0 output
    P2SEL |= BIT5; //2.0 TA1
    P1DIR |= BIT6; //assigns BIT6 to have an output direction
    P1SEL |= ~BIT6; //assigns value of 0 to Pin6 in P1SEL SFR

    __bis_SR_register(LPM0_bits + GIE);       // Enter LPM3, interrupts enabled
    __no_operation();                         // For debugger
}

// USCI Interrupt
#pragma vector=USCI_A1_VECTOR
__interrupt void USCI_A1_ISR(void)
{
    switch(byte)
    {
    case 0:
        first_byte = UCA1RXBUF;
        TA2CCR2 = 2500;
        UCA1TXBUF = 0x2E;
        P1OUT = BIT6;
        break;
    case 1:
        second_byte = UCA1RXBUF;
        break;
    case 2:
        third_byte = UCA1RXBUF;
        break;
    case 3:
        fourth_byte = UCA1RXBUF;
        break;
    case 4:
        fifth_byte = UCA1RXBUF;
        break;
    default:
        break;
    }
    if (byte < 4)
    {
       security_algorithm();
       byte += 1;
    }
    else if (byte == 4)
    {
        if (admin_byte == fifth_byte)
        {
            security = encrypted3;
            TA2CCR2 = 150;
            P1OUT ^= BIT6;
            byte = 0;
            UCA1TXBUF = 67;
        }
    }
    else
    {
       byte = 0;
    }

    if (byte > 3)
    {
        if (encrypted3 == security)
        {
            while (!(UCA0IFG&UCTXIFG));             // USCI_A0 TX buffer ready?
            {
                UCA1TXBUF = 71;
            }
            TA2CCR2 = 150;
            P1OUT ^= BIT6;
            byte = 0;
        }
        else
        {
            UCA1TXBUF = 68;
        }
    }
}


